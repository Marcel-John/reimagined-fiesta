module src/game/logic

import src/game/state

record Shipstorage(
  shipsPlayer: Int,
  shipsAI: Int
)

type Wincon {
  Win()
  Lose()
  InGame()
}

val spawnPlayer = 1
val spawnAI = 1
val spawnNeutral = 0

val battelstrngthPlayer = spawnAI + 1
val battelstrngthAI = spawnPlayer + 1
val battelstrngthNeutral = 0

val Planettest: Planet= Planet(id="-1", x=0, y=0, radius=0, shipsPlayer=0, shipsAI=0, owner=Neutral())
val Planet0: Planet= Planet(id="0", x=0, y=0, radius=100, shipsPlayer=49, shipsAI=0, owner=Player())
val Planet1: Planet= Planet(id="1", x=100, y=100, radius=100, shipsPlayer=0, shipsAI=100, owner=AI())
val freeforAI: Planet= Planet(id="2", x=100, y=100, radius=100, shipsPlayer=0, shipsAI=0, owner=Neutral())
val defaultPlanet: Planet = Planet(id="-1", x=0, y=0, radius=0, shipsPlayer=0, shipsAI=0, owner=Neutral())

def initialGameState(): GameState = {
  GameState(screen = Start(),
  planets = [Planet0, Planet1, freeforAI],
  selected = "")
}

def secondmap(): GameState = {
  GameState(screen = Start(),
  planets = [Planet0, Planet1, freeforAI, Planet(id="3", x=100, y=100, radius=100, shipsPlayer=0, shipsAI=0, owner=Neutral()), Planet(id="4", x=0, y=0, radius=100, shipsPlayer=49, shipsAI=0, owner=Player())],
  selected = "")
}
/*
def generateRandomPlanets(): List[Planet] = {
  val numPlanets = randomInt(7) + 2
  var counter = 0
  var result: List[Planet] = []
  while(counter < numPlanets){
    val shipsPlayer=randomInt(100)
    val shipsAI=randomInt(100)
    val newPlanet:Planet = Planet(show(counter), x=0, y=0, radius=0, shipsPlayer, shipsAI, if(shipsPlayer > shipsAI){Player()}else{AI()})
    result = result.append([newPlanet])
  }
  result
}*/

def addShipstoPlanet(p:Planet, o: Owner, s: Int): Planet ={
  var result = p
  o match{
    case Player() => {result = Planet(p.id, p.x, p.y, p.radius, addNotNegative(p.shipsPlayer, s), p.shipsAI, p.owner)}
    case AI() => {result = Planet(p.id, p.x, p.y, p.radius, p.shipsPlayer, addNotNegative(p.shipsAI, s), p.owner)}
    case Neutral() => {doNothing()}
  }
  result
}

def updateListOfPlanets(l: List[Planet], p: Planet): List[Planet] = {
  var result = l
  var index = 0
  var target = -1
  l.foreach{x =>
  if(x.id == p.id){
    target = index
  }
  index = index + 1
  }
  if(target > -1){
  result  = result.replace(target, p)}
  l
}

def findPlanetbyID(planets: List[Planet], id: String): Planet = {
  var result: Planet = Planettest
  planets.foreach{x=>
  if(x.id == id){
    result = x
  }
  }
  result
}

def calculateHalfOfShips(ships: Int): Int = {
  var result = 0
  if(ships.mod(2) == 0){
    result = ships / 2
  }else{
    result = (ships + 1) / 2
  }
  result
}

// logic for updating planets
def calculatePlanetUpdate(p: Planet): Planet = {
  var result: Planet = p

  val SpawningShips: Shipstorage= calculateamountTSpawn(result)
  result = Planet(result.id, result.x, result.y, result.radius,
  result.shipsPlayer + SpawningShips.shipsPlayer,
  result.shipsAI + SpawningShips.shipsAI,
  result.owner)

  val shipsAfterBattle: Shipstorage= calculatebattel(result)
  result = Planet(result.id, result.x, result.y, result.radius,
  shipsAfterBattle.shipsPlayer,
  shipsAfterBattle.shipsAI,
  result.owner)

  val owner: Owner = changeownershipPlanet(result)
  result = Planet(result.id, result.x, result.y, result.radius,
  result.shipsPlayer,
  result.shipsAI,
  owner)

  result
}

def calculateamountTSpawn(p: Planet): Shipstorage = {
  val owner: Owner = p.owner
  var result: Shipstorage = Shipstorage(0,0)
  owner match {
    case Player() => {result = Shipstorage(spawnPlayer, 0)}
    case AI() => {result = Shipstorage(0, spawnAI)}
    case Neutral() => {doNothing()}
  }
  result
}

def calculatebattel(p: Planet): Shipstorage = {
  var shipsPlayer: Int = p.shipsPlayer
  var shipsAI: Int = p.shipsAI
  if (shipsPlayer > 0 && shipsAI > 0){
    shipsPlayer = subtractionNotNegative(shipsPlayer, battelstrngthAI)
    shipsAI = subtractionNotNegative(shipsAI, battelstrngthPlayer)
  }
  Shipstorage(shipsPlayer, shipsAI)
}

def subtractionNotNegative(ships: Int, amout: Int): Int = {
  var result = ships

  if (ships > amout){
    result = ships - amout
  }else{
    result = 0
  }

  result
}

def addNotNegative(x: Int, y: Int): Int = {
  var result = x + y
  if(result < 0){result = 0}
  result
}

def changeownershipPlanet(p: Planet): Owner = {
  var result: Owner = p.owner

  if(p.shipsPlayer == 0 && p.shipsAI > 0){
    result = AI()
  }

  if(p.shipsAI == 0 && p.shipsPlayer > 0){
    result = Player()
  }

  result
}

def checkWinOrLose(g: GameState): Wincon = {
  val planets: List[Planet] = g.planets
  var hasPlayerPlanets: Bool = false
  var hasAiPlanets: Bool = false
  var result = InGame()

  planets.foreach{x=>
  val p: Planet = x
  if(isOwnedByPlayer(p)){
    hasPlayerPlanets = true
  }
  if(isOwnedByAI(p)){
    hasAiPlanets = true
  }
  }

  if(hasPlayerPlanets && not(hasAiPlanets)){
    result = Win()
  }
  if(not(hasPlayerPlanets) && hasAiPlanets){
    result = Lose()
  }

  result
}

def isOwnedByPlayer(p: Planet): Bool = {
  val owner : Owner = p.owner
  var result : Bool = false

  owner match {
    case Player() =>{result = true}
    case AI() =>{result = false}
    case Neutral() =>{result = false}
  }

  result
}

def isOwnedByAI(p: Planet): Bool = {
  val owner : Owner = p.owner
  var result : Bool = false

  owner match {
    case Player() =>{result = false}
    case AI() =>{result = true}
    case Neutral() =>{result = false}
  }

  result
}

def isOwnedByNeutral(p: Planet): Bool = {
  val owner : Owner = p.owner
  var result : Bool = false

  owner match {
    case Player() =>{result = false}
    case AI() =>{result = false}
    case Neutral() =>{result = true}
  }

  result
}

def isPlayerlogical(o: Owner): Bool = {
  o match {
    case Player() => true
    case _ => false
  }
}

def doNothing(): Unit = {}