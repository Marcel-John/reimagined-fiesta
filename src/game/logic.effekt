module src/game/logic

import src/game/state

record Shipstorage(
  shipsPlayer: Int,
  shipsAI: Int
)

type Wincon {
  Win()
  Lose()
  InGame()
}

val spawnPlayer = 1
val spawnAI = 1
val spawnNeutral = 0

val battelstrngthPlayer = spawnAI + 1
val battelstrngthAI = spawnPlayer + 1
val battelstrngthNeutral = 0

val Planettest: Planet= Planet(id=-1, x=0, y=0, radius=0, shipsPlayer=0, shipsAI=0, owner=Neutral())
val Planet0: Planet= Planet(id=0, x=0, y=0, radius=100, shipsPlayer=49, shipsAI=0, owner=Player())
val Planet1: Planet= Planet(id=1, x=100, y=100, radius=100, shipsPlayer=0, shipsAI=100, owner=AI())
val freeforAI: Planet= Planet(id=2, x=100, y=100, radius=100, shipsPlayer=0, shipsAI=0, owner=Neutral())
val defaultPlanet: Planet = Planet(id=-1, x=0, y=0, radius=0, shipsPlayer=0, shipsAI=0, owner=Neutral())

def initialGameState(): GameState = {
  GameState(screen = Start(),
  planets = [Planet0, Planet1, freeforAI],
  selected = -1)
}

/*
def changePlanets(planets: List[Planet], updatedPlanet: Planet): Unit ={
  if(updatedPlanet.id > -1){return ()}
  var index = 0
  var target = 0
  planets.foreach{x =>
  if(x.id == updatedPlanet.id){
    target = index
  }
  index = index + 1
  }
  planets.replace(target, updatedPlanet)
  println("xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx")
  println(target)
  printAllPlanets(planets)
  ()
}*/

def findPlanetbyID(planets: List[Planet], id: Int): Planet = {
  var result: Planet = Planettest
  planets.foreach{x=>
  if(x.id == id){
    result = x
  }
  }
  result
}
/*
def changeShipsOfPlanet(planets: List[Planet], planet: Planet, shipsPlayernew: Int,
                  shipsAInew:Int): Unit ={
  val newPlanet: Planet = Planet(id=planet.id, x=planet.x,
  y=planet.y, radius=planet.radius, shipsPlayer=shipsPlayernew,
  shipsAI=shipsAInew, owner=planet.owner)
  changePlanets(planets, newPlanet)
}*/

/*
def moveShips(planets: List[Planet], from: Planet, to: Planet, actor: Owner): Unit = {
  actor match {
    case Player() => {
      val shipsToMove: Int = calculateHalfOfShips(from.shipsPlayer)
      val shipsPlayerfrom = from.shipsPlayer - shipsToMove
      val shipsPlayerto = to.shipsPlayer + shipsToMove
      changeShipsOfPlanet(planets, from, shipsPlayerfrom, from.shipsAI)
      changeShipsOfPlanet(planets, to, shipsPlayerto, to.shipsAI)
    }
    case AI() => {
      val shipsToMove: Int = calculateHalfOfShips(from.shipsAI)
      val shipsAIfrom = from.shipsAI - shipsToMove
      val shipsAIto = to.shipsAI + shipsToMove
      changeShipsOfPlanet(planets, from, from.shipsPlayer, shipsAIfrom)
      changeShipsOfPlanet(planets, to, to.shipsPlayer, shipsAIto)
    }
    case Neutral() => doNothing()
  }
}*/

def calculateHalfOfShips(ships: Int): Int = {
  var result = 0
  if(ships.mod(2) == 0){
    result = ships / 2
  }else{
    result = (ships + 1) / 2
  }
  result
}

// logic for updating planets
def calculatePlanetUpdate(p: Planet): Planet = {
  var result: Planet = p

  val SpawningShips: Shipstorage= calculateamountTSpawn(result)
  result = Planet(result.id, result.x, result.y, result.radius,
  result.shipsPlayer + SpawningShips.shipsPlayer,
  result.shipsAI + SpawningShips.shipsAI,
  result.owner)

  val shipsAfterBattle: Shipstorage= calculatebattel(result)
  result = Planet(result.id, result.x, result.y, result.radius,
  shipsAfterBattle.shipsPlayer,
  shipsAfterBattle.shipsAI,
  result.owner)

  val owner: Owner = changeownershipPlanet(result)
  result = Planet(result.id, result.x, result.y, result.radius,
  result.shipsPlayer,
  result.shipsAI,
  owner)

  result
}

def calculateamountTSpawn(p: Planet): Shipstorage = {
  val owner: Owner = p.owner
  var result: Shipstorage = Shipstorage(0,0)
  owner match {
    case Player() => {result = Shipstorage(spawnPlayer, 0)}
    case AI() => {result = Shipstorage(0, spawnAI)}
    case Neutral() => {doNothing()}
  }
  result
}

def calculatebattel(p: Planet): Shipstorage = {
  var shipsPlayer: Int = p.shipsPlayer
  var shipsAI: Int = p.shipsAI
  if (shipsPlayer > 0 && shipsAI > 0){
    shipsPlayer = subtractionNotNegative(shipsPlayer, battelstrngthAI)
    shipsAI = subtractionNotNegative(shipsAI, battelstrngthPlayer)
  }
  Shipstorage(shipsPlayer, shipsAI)
}

def subtractionNotNegative(ships: Int, amout: Int): Int = {
  var result = ships

  if (ships > amout){
    result = ships - amout
  }else{
    result = 0
  }

  result
}

def changeownershipPlanet(p: Planet): Owner = {
  var result: Owner = p.owner

  if(p.shipsPlayer == 0 && p.shipsAI > 0){
    result = AI()
  }

  if(p.shipsAI == 0 && p.shipsPlayer > 0){
    result = Player()
  }

  result
}

def checkWinOrLose(g: GameState): Wincon = {
  val planets: List[Planet] = g.planets
  var hasPlayerPlanets: Bool = false
  var hasAiPlanets: Bool = false
  var result = InGame()

  planets.foreach{x=>
  val p: Planet = x
  if(isOwnedByPlayer(p)){
    hasPlayerPlanets = true
  }
  if(isOwnedByAI(p)){
    hasAiPlanets = true
  }
  }

  if(hasPlayerPlanets && not(hasAiPlanets)){
    result = Win()
  }
  if(not(hasPlayerPlanets) && hasAiPlanets){
    result = Lose()
  }

  result
}

def isOwnedByPlayer(p: Planet): Bool = {
  val owner : Owner = p.owner
  var result : Bool = false

  owner match {
    case Player() =>{result = true}
    case AI() =>{result = false}
    case Neutral() =>{result = false}
  }

  result
}

def isOwnedByAI(p: Planet): Bool = {
  val owner : Owner = p.owner
  var result : Bool = false

  owner match {
    case Player() =>{result = false}
    case AI() =>{result = true}
    case Neutral() =>{result = false}
  }

  result
}

def doNothing(): Unit = {}