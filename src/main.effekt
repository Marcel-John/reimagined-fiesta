module main // must be named same as the file!

import src/lib
import src/game/logic
import src/game/state
import src/effects/gamesate
import src/ffi/input
import src/game/ai


def main(): Unit = {
  // test loop
//gameloop()
// 
//console version
consolegameloop()

println(helloWorld())
}

def consolegameloop() : Unit = {
  // some inital states
  var isGameRunning: Bool = true
  var state: GameState = initialGameState()
  var planets:List[Planet] = state.planets

  // updateting planets using effects
def planetschangable = new UpdatePlanets{
  def updatePlanet(planet: Planet) = {
    if(planet.id > -1){return ()}
  var index = 0
  var target = -1
  planets.foreach{x =>
  if(x.id == planet.id){
    target = index
  }
  index = index + 1
  }
  // this is dumb why not impus as pointers why
  if(target > -1){
  planets = planets.replace(target, planet)}
  // for unit
  ()
  }
}

// updating gamestate using effects
def gamesate = new UpdateGamestate{
  def changePlanets(p:List[Planet]) = {
    val newstate = GameState(
      screen = state.screen,
      planets = p,
      selected = state.selected)
    state = newstate
    ()
  }

  def cahngeSelected(s: Int) = {
    val newstate = GameState(
      screen = state.screen,
      planets = state.planets,
      selected = s)
    state = newstate
    ()
  }

  def changeScreen(newScreen: Screen) = {
    val newstate = GameState(
      screen = newScreen,
      planets = state.planets,
      selected = state.selected)
    state = newstate
    ()
  }
  def getGameState() = {state}
}

// actual loop
  while(isGameRunning){
    // managing the start screen
    if(isStartscreen(state.screen)){
      printStartscreen()
      var input = getInput()
      input match{
        case "s" => gamesate.changeScreen(Game())
        case "q" => isGameRunning = false
        case _ => ()
      }
    }

    // Game Loop
    if(isGamescreen(state.screen)){

      // Player turn
      drawGameState(gamesate.getGameState(), Player())
      var input: String = getInput()
      var inputInt: Int = -1
      input match {
        case "" => gamesate.cahngeSelected(-1)
        case "q" => isGameRunning = false
        case "0" => inputInt = 0
        case "1" => inputInt = 1
        case "2" => inputInt = 2
        case "3" => inputInt = 3
        case "4" => inputInt = 4
        case "5" => inputInt = 5
        case "6" => inputInt = 6
        case "7" => inputInt = 7
        case "8" => inputInt = 8
        case "9" => inputInt = 9
        case _ => ()
        }
      var p: Planet = findPlanetbyID(planets, inputInt)
      if(p.id != -1){
        if(state.selected == -1){
          gamesate.cahngeSelected(inputInt)
        }else{
          moveShips(findPlanetbyID(planets, state.selected), findPlanetbyID(planets, inputInt), Player()){planetschangable}
          gamesate.cahngeSelected(-1)
        }
      }
      

      // AI turn
      var aimove:AIMovedecision = makeMoveDessision(state)
      var didMove: Bool = aimove.isturnUsed
      var from: Int = aimove.move.from.id
      var to: Int = aimove.move.to.id
      printAIMove(didMove, from, to)
      moveShips(findPlanetbyID(planets, from), findPlanetbyID(planets, to), AI()){planetschangable}
      
      // updating the game
      updatePlanets(planets){planetschangable}
      updateGamestate(planets){gamesate}
      applyWinCon(state){gamesate}
    }

    if(isGameOverscreen(state.screen)){
      var hasPlayerWon: Bool = hasPlayerWon(state.screen)
      endScreen(hasPlayerWon)
      var input: String = getInput()
      input match{
        case _ => gamesate.changeScreen(Start())
      }
    }
  }
}

//------------------------------- testing
def gameloop() : Unit = {
  var state: GameState = initialGameState()
  // showing initial game state
  printGameState(state)


  // move some ships for testing
  var planets:List[Planet] = state.planets
  var planet0: Planet = findPlanetbyID(planets, 0)
  var planet1: Planet = findPlanetbyID(planets, 1)

// updateting planets using effects
def planetschangable = new UpdatePlanets{
  def updatePlanet(planet: Planet) = {
    if(planet.id > -1){return ()}
  var index = 0
  var target = 0
  planets.foreach{x =>
  if(x.id == planet.id){
    target = index
  }
  index = index + 1
  }
  // this is dumb why not impus as pointers why
  planets = planets.replace(target, planet)
  // for unit
  ()
  }
}

// updating gamestate using effects
def gamesate = new UpdateGamestate{
  def changePlanets(p:List[Planet]) = {
    val newstate = GameState(
      screen = state.screen,
      planets = p,
      selected = state.selected)
    state = newstate
    ()
  }

  def cahngeSelected(s: Int) = {
    val newstate = GameState(
      screen = state.screen,
      planets = state.planets,
      selected = s)
    state = newstate
    ()
  }

  def changeScreen(newScreen: Screen) = {
    val newstate = GameState(
      screen = newScreen,
      planets = state.planets,
      selected = state.selected)
    state = newstate
    ()
  }
  def getGameState() = {state}
}

moveShips(findPlanetbyID(planets, 0), findPlanetbyID(planets, 1), Player()){planetschangable}
moveShips(findPlanetbyID(planets, 0), findPlanetbyID(planets, 1), Player()){planetschangable}

println("now the input")
val input = getInput()
println(input)

// checkin after 99 rounds
var i = 0
while(i < 100){
  i = i + 1
  moveShips(findPlanetbyID(planets, 0), findPlanetbyID(planets, 1), Player()){planetschangable}
  updatePlanets(planets){planetschangable}
}


updateGamestate(planets){gamesate}
applyWinCon(state){gamesate}
// prints for checking
//println("-----------------------------------------------")
//printAllPlanets(planets)
//println("-----------------------------------------------")
printGameState(state)
}


// Helper functions-------------------------------------

def applyWinCon(g:GameState){s: UpdateGamestate}: Unit ={
  val stateOfGame: Wincon = checkWinOrLose(g)
  stateOfGame match{
    case InGame() => {doNothing()}
    case Win() => {s.changeScreen(EndWin())}
    case Lose() => {s.changeScreen(EndLose())}
  }
}

def updatePlanets(p:List[Planet]){u: UpdatePlanets}: Unit ={
  p.foreach {x=>
  val changedPlanet: Planet = calculatePlanetUpdate(x)
  u.updatePlanet(changedPlanet)
  }
}

def updateGamestate(p:List[Planet]){s: UpdateGamestate}: Unit = {
  s.changePlanets(p)
}

def changeShipsOfPlanet(planet: Planet, shipsPlayernew: Int,
                  shipsAInew:Int){u: UpdatePlanets}: Unit ={
  val newPlanet: Planet = Planet(id=planet.id, x=planet.x,
  y=planet.y, radius=planet.radius, shipsPlayer=shipsPlayernew,
  shipsAI=shipsAInew, owner=planet.owner)
  u.updatePlanet(newPlanet)
}

def moveShips(from: Planet, to: Planet, actor: Owner){u: UpdatePlanets}: Unit = {
  actor match {
    case Player() => {
      val shipsToMove: Int = calculateHalfOfShips(from.shipsPlayer)
      val shipsPlayerfrom = from.shipsPlayer - shipsToMove
      val shipsPlayerto = to.shipsPlayer + shipsToMove
      changeShipsOfPlanet(from, shipsPlayerfrom, from.shipsAI){u}
      changeShipsOfPlanet(to, shipsPlayerto, to.shipsAI){u}
    }
    case AI() => {
      val shipsToMove: Int = calculateHalfOfShips(from.shipsAI)
      val shipsAIfrom = from.shipsAI - shipsToMove
      val shipsAIto = to.shipsAI + shipsToMove
      changeShipsOfPlanet(from, from.shipsPlayer, shipsAIfrom){u}
      changeShipsOfPlanet(to, to.shipsPlayer, shipsAIto){u}
    }
    case Neutral() => doNothing()
  }
}