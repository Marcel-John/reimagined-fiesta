module main // must be named same as the file!

import src/lib
import src/game/logic
import src/game/state
import src/effects/gamesate
import src/ffi/input
import src/game/ai


def main(): Unit = {
  // test loop
//gameloop()
// 
//console version
mainMenu()
//consolegameloop()

println(helloWorld())
}

def mainMenu() : Unit = {
  try{
    while(true){
      printMainMenu()
      var input = getInput()
      input match{
        case "q" => do break(2)
        case "n" => consolegameloop()
        case "a" => aiVsAi()
        case "p" => pVP()
        case _ => doNothing()
      }
    }
  }with Multibreak {
    def break(n) = {
      val numberOfBreaks: Int = n - 1
    }
  }
}


def consolegameloop() : Unit/Multibreak = {
  
  // some inital states
  var state: GameState = initialGameState()
  var planets:List[Planet] = state.planets

  // updateting planets using effects
def planetschangable = new UpdatePlanets{
  def updatePlanet(planet: Planet) = {
    if(planet.id == ""){return ()}
  var index = 0
  var target = -1
  planets.foreach{x =>
  if(x.id == planet.id){
    target = index
  }
  index = index + 1
  }
  if(target > -1){
  planets = planets.replace(target, planet)}
  // for unit
  ()
  }
}

// updating gamestate using effects
def gamesate = new UpdateGamestate{
  def changePlanets(p:List[Planet]) = {
    val newstate = GameState(
      screen = state.screen,
      planets = p,
      selected = state.selected)
    state = newstate
    ()
  }

  def cahngeSelected(s: String) = {
    val newstate = GameState(
      screen = state.screen,
      planets = state.planets,
      selected = s)
    state = newstate
    ()
  }

  def changeScreen(newScreen: Screen) = {
    val newstate = GameState(
      screen = newScreen,
      planets = state.planets,
      selected = state.selected)
    state = newstate
    ()
  }
  def getScreen() = {state.screen}
  def getGameState() = {state}
  def newGameState(g: GameState) ={
    state = g
  }
  def getPlanests() = {state.planets}
  def getSelected() = {state.selected}

}

// actual loop
try{
  while(true){
    // managing the start screen
    if(isStartscreen(gamesate.getScreen())){
      printStartscreen("normal game")
      var input = getInput()
      input match{
        case "s" => gamesate.changeScreen(Game())
        case "q" => do break(2)
        case "r" => do break(1)
        case _ => ()
      }
    }

    // Game Loop
    if(isGamescreen(gamesate.getScreen())){

      // Player turn
      drawGameState(gamesate.getGameState(), Player())
      var input: String = getInput()
      input match {
        case "" => gamesate.cahngeSelected("")
        case "q" => do break(2)
        case "r" => do break(1)
        case _ => ()
        }
      var p: Planet = findPlanetbyID(planets, input)
      if(p.id != "-1"){
        if(gamesate.getSelected() == "" || gamesate.getSelected() == input){
          gamesate.cahngeSelected(input)
        }else{
          moveShips(findPlanetbyID(planets, gamesate.getSelected()), findPlanetbyID(planets, input), Player()){planetschangable}
          gamesate.cahngeSelected("")
        }
      }
      

      // AI turn
      var aimove:AIMovedecision = makeMoveDessision(gamesate.getGameState(), AI())
      var didMove: Bool = aimove.isturnUsed
      var from: String = aimove.move.from.id
      var to: String = aimove.move.to.id
      printAIMove(didMove, from, to)
      moveShips(findPlanetbyID(planets, from), findPlanetbyID(planets, to), AI()){planetschangable}
      
      // updating the game
      updatePlanets(planets){planetschangable}
      updateGamestate(planets){gamesate}
      applyWinCon(state){gamesate}
    }

    if(isGameOverscreen(gamesate.getScreen())){
      var hasPlayerWon: Bool = hasPlayerWon(gamesate.getScreen())
      endScreen(hasPlayerWon)
      var input: String = getInput()
      input match{
        case _ => {
          gamesate.newGameState(initialGameState())
          do break(1)
        }
      }
    }
  }
  }with Multibreak {
    def break(n) = {
      val numberOfBreaks: Int = n - 1
      if(numberOfBreaks > 0){
        do break(n)
      }
    }
  }
}

def pVP() : Unit/Multibreak = {
  // some inital states
  var state: GameState = initialGameState()
  var planets:List[Planet] = state.planets
  var player1Selected: String = "" 
  var player2Selected: String = "" 

  // updateting planets using effects
def planetschangable = new UpdatePlanets{
  def updatePlanet(planet: Planet) = {
    if(planet.id == ""){return ()}
  var index = 0
  var target = -1
  planets.foreach{x =>
  if(x.id == planet.id){
    target = index
  }
  index = index + 1
  }
  if(target > -1){
  planets = planets.replace(target, planet)}
  // for unit
  ()
  }
}

// updating gamestate using effects
def gamesate = new UpdateGamestate{
  def changePlanets(p:List[Planet]) = {
    val newstate = GameState(
      screen = state.screen,
      planets = p,
      selected = state.selected)
    state = newstate
    ()
  }

  def cahngeSelected(s: String) = {
    val newstate = GameState(
      screen = state.screen,
      planets = state.planets,
      selected = s)
    state = newstate
    ()
  }

  def changeScreen(newScreen: Screen) = {
    val newstate = GameState(
      screen = newScreen,
      planets = state.planets,
      selected = state.selected)
    state = newstate
    ()
  }
  def getScreen() = {state.screen}
  def getGameState() = {state}
  def newGameState(g: GameState) ={
    state = g
  }
  def getPlanests() = {state.planets}
  def getSelected() = {state.selected}

}

// actual loop
try{
  while(true){
    // managing the start screen
    if(isStartscreen(gamesate.getScreen())){
      printStartscreen("PVP game")
      var input = getInput()
      input match{
        case "s" => gamesate.changeScreen(Game())
        case "q" => do break(2)
        case "r" => do break(1)
        case _ => ()
      }
    }

    // Game Loop
    if(isGamescreen(gamesate.getScreen())){

      // Player turn
      gamesate.cahngeSelected(player1Selected)
      drawGameStatepvp(gamesate.getGameState(), Player())
      var input: String = getInputWithTimeout()
      input match {
        case "" => gamesate.cahngeSelected("")
        case "q" => do break(2)
        case "r" => do break(1)
        case _ => ()
        }
      var p: Planet = findPlanetbyID(planets, input)
      if(p.id != "-1"){
        if(gamesate.getSelected() == "" || gamesate.getSelected() == input){
          gamesate.cahngeSelected(input)
        }else{
          moveShips(findPlanetbyID(planets, gamesate.getSelected()), findPlanetbyID(planets, input), Player()){planetschangable}
          gamesate.cahngeSelected("")
        }
      }
      player1Selected = gamesate.getSelected()

      // Player 2 turn
      gamesate.cahngeSelected(player2Selected)
      drawGameStatepvp(gamesate.getGameState(), AI())
      input = getInputWithTimeout()
      input match {
        case "" => gamesate.cahngeSelected("")
        case "q" => do break(2)
        case "r" => do break(1)
        case _ => ()
        }
      p = findPlanetbyID(planets, input)
      if(p.id != "-1"){
        if(gamesate.getSelected() == "" || gamesate.getSelected() == input){
          gamesate.cahngeSelected(input)
        }else{
          moveShips(findPlanetbyID(planets, gamesate.getSelected()), findPlanetbyID(planets, input), AI()){planetschangable}
          gamesate.cahngeSelected("")
        }
      }
      player2Selected = gamesate.getSelected()
      
      // updating the game
      updatePlanets(planets){planetschangable}
      updateGamestate(planets){gamesate}
      applyWinCon(state){gamesate}
    }

    if(isGameOverscreen(gamesate.getScreen())){
      var hasPlayerWon: Bool = hasPlayerWon(gamesate.getScreen())
      endScreen(hasPlayerWon)
      var input: String = getInput()
      input match{
        case _ => {
          gamesate.newGameState(initialGameState())
          do break(1)
        }
      }
    }
  }
  }with Multibreak {
    def break(n) = {
      val numberOfBreaks: Int = n - 1
      if(numberOfBreaks > 0){
        do break(n)
      }
    }
  }
}

def aiVsAi(): Unit/Multibreak = {
  // some inital states
  var state: GameState = initialGameState()
  var planets:List[Planet] = state.planets

  // updateting planets using effects
def planetschangable = new UpdatePlanets{
  def updatePlanet(planet: Planet) = {
    if(planet.id == ""){return ()}
  var index = 0
  var target = -1
  planets.foreach{x =>
  if(x.id == planet.id){
    target = index
  }
  index = index + 1
  }
  if(target > -1){
  planets = planets.replace(target, planet)}
  // for unit
  ()
  }
}

// updating gamestate using effects
def gamesate = new UpdateGamestate{
  def changePlanets(p:List[Planet]) = {
    val newstate = GameState(
      screen = state.screen,
      planets = p,
      selected = state.selected)
    state = newstate
    ()
  }

  def cahngeSelected(s: String) = {
    val newstate = GameState(
      screen = state.screen,
      planets = state.planets,
      selected = s)
    state = newstate
    ()
  }

  def changeScreen(newScreen: Screen) = {
    val newstate = GameState(
      screen = newScreen,
      planets = state.planets,
      selected = state.selected)
    state = newstate
    ()
  }
  def getScreen() = {state.screen}
  def getGameState() = {state}
  def newGameState(g: GameState) ={
    state = g
  }
  def getPlanests() = {state.planets}
  def getSelected() = {state.selected}

}

// actual loop
try{
  while(true){
    // managing the start screen
    if(isStartscreen(gamesate.getScreen())){
      printStartscreen("AI VS AI")
      var input = getInput()
      input match{
        case "s" => gamesate.changeScreen(Game())
        case "q" => do break(2)
        case "r" => do break(1)
        case _ => ()
      }
    }

    // Game Loop
    if(isGamescreen(gamesate.getScreen())){

      // PlayerAI turn
      drawGameStateAIvsAI(gamesate.getGameState())
      var input: String = getInputWithTimeout()
      input match {
        case "q" => do break(2)
        case "r" => do break(1)
        case _ => ()
        }
      // PlayerAI turn
      var aimovep:AIMovedecision = makeMoveDessision(gamesate.getGameState(), Player())
      var didMovep: Bool = aimovep.isturnUsed
      var fromp: String = aimovep.move.from.id
      var top: String = aimovep.move.to.id
      printAIMove(didMovep, fromp, top)
      moveShips(findPlanetbyID(planets, fromp), findPlanetbyID(planets, top), Player()){planetschangable}
      

      // AI turn
      var aimove:AIMovedecision = makeMoveDessision(gamesate.getGameState(), AI())
      var didMove: Bool = aimove.isturnUsed
      var from: String = aimove.move.from.id
      var to: String = aimove.move.to.id
      printAIMove(didMove, from, to)
      moveShips(findPlanetbyID(planets, from), findPlanetbyID(planets, to), AI()){planetschangable}
      
      // updating the game
      updatePlanets(planets){planetschangable}
      updateGamestate(planets){gamesate}
      applyWinCon(state){gamesate}
    }

    if(isGameOverscreen(gamesate.getScreen())){
      var hasPlayerWon: Bool = hasPlayerWon(gamesate.getScreen())
      endScreen(hasPlayerWon)
      var input: String = getInput()
      input match{
        case _ => {
          gamesate.newGameState(initialGameState())
          do break(1)
        }
      }
    }
  }
  }with Multibreak {
    def break(n) = {
      val numberOfBreaks: Int = n - 1
      if(numberOfBreaks > 0){
        do break(n)
      }
    }
  }
}





//------------------------------- testing
/*
def gameloop() : Unit = {
  var state: GameState = initialGameState()
  // showing initial game state
  printGameState(state)


  // move some ships for testing
  var planets:List[Planet] = state.planets
  var planet0: Planet = findPlanetbyID(planets, 0)
  var planet1: Planet = findPlanetbyID(planets, 1)

// updateting planets using effects
def planetschangable = new UpdatePlanets{
  def updatePlanet(planet: Planet) = {
    if(planet.id > -1){return ()}
  var index = 0
  var target = 0
  planets.foreach{x =>
  if(x.id == planet.id){
    target = index
  }
  index = index + 1
  }
  // this is dumb why not impus as pointers why
  planets = planets.replace(target, planet)
  // for unit
  ()
  }
}

// updating gamestate using effects
def gamesate = new UpdateGamestate{
  def changePlanets(p:List[Planet]) = {
    val newstate = GameState(
      screen = state.screen,
      planets = p,
      selected = state.selected)
    state = newstate
    ()
  }
def getScreen() = {state.screen}
  def cahngeSelected(s: Int) = {
    val newstate = GameState(
      screen = state.screen,
      planets = state.planets,
      selected = s)
    state = newstate
    ()
  }

  def changeScreen(newScreen: Screen) = {
    val newstate = GameState(
      screen = newScreen,
      planets = state.planets,
      selected = state.selected)
    state = newstate
    ()
  }
  def getGameState() = {state}
  def newGameState(g: GameState) ={
    state = g
  }
}

moveShips(findPlanetbyID(planets, 0), findPlanetbyID(planets, 1), Player()){planetschangable}
moveShips(findPlanetbyID(planets, 0), findPlanetbyID(planets, 1), Player()){planetschangable}

println("now the input")
val input = getInput()
println(input)

// checkin after 99 rounds
var i = 0
while(i < 100){
  i = i + 1
  moveShips(findPlanetbyID(planets, 0), findPlanetbyID(planets, 1), Player()){planetschangable}
  updatePlanets(planets){planetschangable}
}


updateGamestate(planets){gamesate}
applyWinCon(state){gamesate}
// prints for checking
//println("-----------------------------------------------")
//printAllPlanets(planets)
//println("-----------------------------------------------")
printGameState(state)
}*/


// Helper functions-------------------------------------

def applyWinCon(g:GameState){s: UpdateGamestate}: Unit ={
  val stateOfGame: Wincon = checkWinOrLose(g)
  stateOfGame match{
    case InGame() => {doNothing()}
    case Win() => {s.changeScreen(EndWin())}
    case Lose() => {s.changeScreen(EndLose())}
  }
}

def updatePlanets(p:List[Planet]){u: UpdatePlanets}: Unit ={
  p.foreach {x=>
  val changedPlanet: Planet = calculatePlanetUpdate(x)
  u.updatePlanet(changedPlanet)
  }
}

def updateGamestate(p:List[Planet]){s: UpdateGamestate}: Unit = {
  s.changePlanets(p)
}

def changeShipsOfPlanet(planet: Planet, shipsPlayernew: Int,
                  shipsAInew:Int){u: UpdatePlanets}: Unit ={
  val newPlanet: Planet = Planet(id=planet.id, x=planet.x,
  y=planet.y, radius=planet.radius, shipsPlayer=shipsPlayernew,
  shipsAI=shipsAInew, owner=planet.owner)
  u.updatePlanet(newPlanet)
}

def moveShips(from: Planet, to: Planet, actor: Owner){u: UpdatePlanets}: Unit = {
  actor match {
    case Player() => {
      val shipsToMove: Int = calculateHalfOfShips(from.shipsPlayer)
      val shipsPlayerfrom = from.shipsPlayer - shipsToMove
      val shipsPlayerto = to.shipsPlayer + shipsToMove
      changeShipsOfPlanet(from, shipsPlayerfrom, from.shipsAI){u}
      changeShipsOfPlanet(to, shipsPlayerto, to.shipsAI){u}
    }
    case AI() => {
      val shipsToMove: Int = calculateHalfOfShips(from.shipsAI)
      val shipsAIfrom = from.shipsAI - shipsToMove
      val shipsAIto = to.shipsAI + shipsToMove
      changeShipsOfPlanet(from, from.shipsPlayer, shipsAIfrom){u}
      changeShipsOfPlanet(to, to.shipsPlayer, shipsAIto){u}
    }
    case Neutral() => doNothing()
  }
}